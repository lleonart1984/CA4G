//#ifndef DXR_SUPPORT_H
//#define DXR_SUPPORT_H
//
//#include "ca4g_techniques.h"
//#include "ca4g_pipelines.h"
//#include <wchar.h>
//
//namespace CA4G {
//
//	class Library;
//	class IRTProgram;
//	struct DX_ProgramWrapper;
//	template<typename L> class RTProgram;
//	struct DX_RTPipelineWrapper;
//	struct DX_LibraryWrapper;
//
//#pragma region Programs handles
//
//	class ProgramHandle {
//		friend Library;
//		friend IRTProgram;
//
//		LPCWSTR shaderHandle;
//		void* cachedShaderIdentifier = nullptr;
//	protected:
//		ProgramHandle(LPCWSTR handle) :shaderHandle(handle) {}
//	public:
//		ProgramHandle() :shaderHandle(nullptr) {}
//		ProgramHandle(const ProgramHandle& other) {
//			this->shaderHandle = other.shaderHandle;
//		}
//		inline bool IsNull() { return shaderHandle == nullptr; }
//	};
//
//	class MissHandle : public ProgramHandle {
//		friend Library;
//
//		MissHandle(LPCWSTR shaderHandle) : ProgramHandle(shaderHandle) { }
//	public:
//		MissHandle() : ProgramHandle() {}
//		MissHandle(const MissHandle& other) : ProgramHandle(other) { }
//	};
//
//	class RayGenerationHandle : public ProgramHandle {
//		friend Library;
//		RayGenerationHandle(LPCWSTR shaderHandle) : ProgramHandle(shaderHandle) {}
//	public:
//		RayGenerationHandle() : ProgramHandle() { }
//		RayGenerationHandle(const RayGenerationHandle& other) : ProgramHandle(other) { }
//	};
//
//	class AnyHitHandle : public ProgramHandle {
//		friend Library;
//
//		AnyHitHandle(LPCWSTR shaderHandle) : ProgramHandle(shaderHandle) {}
//	public:
//		AnyHitHandle() : ProgramHandle() { }
//		AnyHitHandle(const AnyHitHandle& other) : ProgramHandle(other) { }
//	};
//
//	class ClosestHitHandle : public ProgramHandle {
//		friend Library;
//
//		ClosestHitHandle(LPCWSTR shaderHandle) : ProgramHandle(shaderHandle) {}
//	public:
//		ClosestHitHandle() : ProgramHandle() { }
//		ClosestHitHandle(const ClosestHitHandle& other) : ProgramHandle(other) { }
//	};
//
//	class IntersectionHandle : public ProgramHandle {
//		friend Library;
//
//		IntersectionHandle(LPCWSTR shaderHandle) : ProgramHandle(shaderHandle) {}
//	public:
//		IntersectionHandle() : ProgramHandle() { }
//		IntersectionHandle(const IntersectionHandle& other) : ProgramHandle(other) { }
//	};
//
//	class HitGroupHandle : public ProgramHandle {
//		friend Library;
//		friend IRTProgram;
//
//		static LPCWSTR CreateAutogeneratedName() {
//			static int ID = 0;
//
//			wchar_t* label = new wchar_t[100];
//			label[0] = 0;
//			wcscat_s(label, 100, TEXT("HITGROUP"));
//			wsprintf(&label[8], L"%d",
//				ID);
//			ID++;
//
//			return label;
//		}
//
//		gObj<AnyHitHandle> anyHit;
//		gObj<ClosestHitHandle> closestHit;
//		gObj<IntersectionHandle> intersection;
//
//		HitGroupHandle(gObj<ClosestHitHandle> closestHit, gObj<AnyHitHandle> anyHit, gObj<IntersectionHandle> intersection)
//			: ProgramHandle(CreateAutogeneratedName()), anyHit(anyHit), closestHit(closestHit), intersection(intersection) {}
//	public:
//		HitGroupHandle() :ProgramHandle() {}
//		HitGroupHandle(const HitGroupHandle& other) :ProgramHandle(other) {
//			this->anyHit = other.anyHit;
//			this->closestHit = other.closestHit;
//			this->intersection = other.intersection;
//		}
//	};
//
//#pragma endregion
//
//	/// Represents a base class for all raytracing programs.
//	class IRTProgram {
//		template<typename L> friend class RTProgram;
//		friend RaytracingPipelineBindings;
//
//		DX_ProgramWrapper* __DXProgramWrapper;
//		// Gets or sets the context where this program is created.
//
//		// Loads this program to be accessible from a Raytracing Manager
//		// This method will collect bindings.
//		void OnLoad(gObj<Library> library);
//		gObj<Library> __Library;
//	protected:
//
//		// When implemented load libraries, the main program and setup program attributes.
//		virtual void Setup() = 0;
//
//		virtual void Globals(gObj<RaytracingBinder> binder) { }
//		
//		virtual void Locals_RayGeneration(gObj<RaytracingBinder> binder) { }
//		
//		virtual void Locals_Miss(gObj<RaytracingBinder> binder) { }
//		
//		virtual void Locals_HitGroup(gObj<RaytracingBinder> binder) { }
//
//		IRTProgram() : set(new Settings(this)), load(new Loader(this)) {
//		}
//
//	public:
//
//		class Settings {
//			IRTProgram* manager;
//		public:
//			Settings(IRTProgram* manager) :manager(manager) {}
//			void Payload(int sizeInBytes);
//			void MaxHitGroupIndex(int index);
//			void StackSize(int maxDeep);
//			void Attribute(int sizeInBytes);
//		}* const set;
//
//		class Loader {
//			IRTProgram* manager;
//		public:
//			Loader(IRTProgram* manager) :manager(manager) { }
//
//			void Shader(gObj<RayGenerationHandle> handle);
//
//			void Shader(gObj<MissHandle> handle);
//
//			void Shader(gObj<HitGroupHandle> handle);
//
//		}* const load;
//
//		virtual ~IRTProgram() {}
//	};
//
//	// Represents a Library of raytracing shaders
//	class Library {
//		friend DX_RTPipelineWrapper;
//		friend RaytracingPipelineBindings;
//
//		list<DX_LibraryWrapper> __DXLibraries;
//
//		Library() :
//			load(new Loading(this)),
//			create(new Creating(this)) {
//		}
//	protected:
//		virtual void OnLoad() = 0;
//
//		class Loading {
//			friend Library;
//			Library* library;
//			Loading(Library* library): library(library){}
//		public:
//			void Code(D3D12_SHADER_BYTECODE code);
//		} * const load;
//
//		class Creating {
//			friend Library;
//			Library* library;
//			Creating(Library* library) :library(library) {}
//		public:
//			gObj<RayGenerationHandle> RayGenerationShader(LPCWSTR shader);
//			gObj<MissHandle> MissShader(LPCWSTR shader);
//			gObj<AnyHitHandle> AnyHit(LPCWSTR shader);
//			gObj<ClosestHitHandle> ClosestHit(LPCWSTR shader);
//			gObj<IntersectionHandle> Intersection(LPCWSTR shader);
//			gObj<HitGroupHandle> HitGroup(gObj<ClosestHitHandle> closest, gObj<AnyHitHandle> anyHit, gObj<IntersectionHandle> intersection);
//		} * const create;
//	public:
//		~Library() {
//			delete load;
//			delete create;
//		}
//	};
//
//	template<typename L>
//	class RTProgram : public IRTProgram {
//	public:
//		inline gObj<L> Library() {
//			return __Library.Dynamic_Cast<L>();
//		}
//	};
//
//	class RTScene {
//		void* __InternalRTWrapper;
//	};
//
//	class DynamicStateBindings {
//
//		friend RaytracingPipelineBindings;
//		template<typename S, D3D12_STATE_SUBOBJECT_TYPE Type> friend class DynamicStateBindingOf;
//
//		D3D12_STATE_SUBOBJECT* dynamicStates;
//
//		void AllocateStates(int length) {
//			dynamicStates = new D3D12_STATE_SUBOBJECT[length];
//		}
//
//		template<typename D>
//		D* GetState(int index) {
//			return (D*)dynamicStates[index].pDesc;
//		}
//
//		template<typename D>
//		void SetState(int index, D3D12_STATE_SUBOBJECT_TYPE type, D* state) {
//			dynamicStates[index].Type = type;
//			dynamicStates[index].pDesc = state;
//		}
//
//	public:
//		DynamicStateBindings() {}
//	};
//
//	template<typename S, D3D12_STATE_SUBOBJECT_TYPE Type>
//	class DynamicStateBindingOf : public virtual DynamicStateBindings {
//	protected:
//		S* GetState(int index) {
//			return GetState<S>(index);
//		}
//
//		S* GetAfterCreate(int index) {
//			S* state = new S{ };
//			SetState(index, Type, state);
//			return state;
//		}
//	public:
//	};
//
//#pragma region Dynamic States
//
//	struct GlobalRootSignatureManager : public DynamicStateBindingOf<D3D12_GLOBAL_ROOT_SIGNATURE, D3D12_STATE_SUBOBJECT_TYPE_GLOBAL_ROOT_SIGNATURE> {
//		void SetGlobalRootSignature(int index, ID3D12RootSignature* rootSignature) {
//			auto state = GetAfterCreate(index);
//			state->pGlobalRootSignature = rootSignature;
//		}
//	};
//
//	struct LocalRootSignatureManager : public DynamicStateBindingOf<D3D12_LOCAL_ROOT_SIGNATURE, D3D12_STATE_SUBOBJECT_TYPE_LOCAL_ROOT_SIGNATURE> {
//		void SetLocalRootSignature(int index, ID3D12RootSignature* rootSignature) {
//			auto state = GetAfterCreate(index);
//			state->pLocalRootSignature = rootSignature;
//		}
//	};
//
//	struct HitGroupManager : public virtual DynamicStateBindingOf<D3D12_HIT_GROUP_DESC, D3D12_STATE_SUBOBJECT_TYPE_HIT_GROUP> {
//		void SetTriangleHitGroup(int index, LPCWSTR exportName, LPCWSTR anyHit, LPCWSTR closestHit) {
//			auto hg = GetAfterCreate(index);
//			hg->AnyHitShaderImport = anyHit;
//			hg->ClosestHitShaderImport = closestHit;
//			hg->IntersectionShaderImport = nullptr;
//			hg->Type = D3D12_HIT_GROUP_TYPE_TRIANGLES;
//			hg->HitGroupExport = exportName;
//		}
//		void SetProceduralGeometryHitGroup(int index, LPCWSTR exportName, LPCWSTR anyHit, LPCWSTR closestHit, LPCWSTR intersection) {
//			auto hg = GetAfterCreate(index);
//			hg->AnyHitShaderImport = anyHit;
//			hg->ClosestHitShaderImport = closestHit;
//			hg->IntersectionShaderImport = intersection;
//			hg->Type = D3D12_HIT_GROUP_TYPE_PROCEDURAL_PRIMITIVE;
//			hg->HitGroupExport = exportName;
//		}
//	};
//
//	struct DXILManager : public virtual DynamicStateBindingOf<D3D12_DXIL_LIBRARY_DESC, D3D12_STATE_SUBOBJECT_TYPE_DXIL_LIBRARY> {
//		void SetDXIL(int index, D3D12_SHADER_BYTECODE bytecode, list<D3D12_EXPORT_DESC>& exports) {
//			auto dxil = GetAfterCreate(index);
//			dxil->DXILLibrary = bytecode;
//			dxil->NumExports = exports.size();
//			dxil->pExports = &exports.first();
//		}
//	};
//
//	struct RTShaderConfig : public virtual DynamicStateBindingOf<D3D12_RAYTRACING_SHADER_CONFIG, D3D12_STATE_SUBOBJECT_TYPE_RAYTRACING_SHADER_CONFIG>
//	{
//		void SetRTSizes(int index, int maxAttributeSize, int maxPayloadSize) {
//			auto state = GetAfterCreate(index);
//			state->MaxAttributeSizeInBytes = maxAttributeSize;
//			state->MaxPayloadSizeInBytes = maxPayloadSize;
//		}
//	};
//
//	struct RTPipelineConfig : public virtual DynamicStateBindingOf<D3D12_RAYTRACING_PIPELINE_CONFIG, D3D12_STATE_SUBOBJECT_TYPE_RAYTRACING_PIPELINE_CONFIG>
//	{
//		void SetMaxRTRecursion(int index, int maxRecursion) {
//			auto state = GetAfterCreate(index);
//			state->MaxTraceRecursionDepth = maxRecursion;
//		}
//	};
//
//	struct ExportsManager : public virtual DynamicStateBindingOf<D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION, D3D12_STATE_SUBOBJECT_TYPE_SUBOBJECT_TO_EXPORTS_ASSOCIATION>
//	{
//		void SetExportsAssociations(int index, D3D12_STATE_SUBOBJECT* ptrToSubobject, const list<LPCWSTR>& exports) {
//			auto state = GetAfterCreate(index);
//			state->pSubobjectToAssociate = ptrToSubobject;
//			state->NumExports = exports.size();
//			state->pExports = &exports.first();
//		}
//	};
//
//#pragma endregion
//
//	struct RaytracingPipelineBindings : public virtual DynamicStateBindings,
//		DXILManager,
//		GlobalRootSignatureManager,
//		LocalRootSignatureManager,
//		HitGroupManager,
//		RTShaderConfig,
//		RTPipelineConfig,
//		ExportsManager
//	{
//		friend RaytracingManager;
//		friend Loading;
//		friend IRTProgram;
//	private:
//
//		DX_RTPipelineWrapper* wrapper;
//
//		// Will be executed when this pipeline manager were loaded
//		void OnCreate(DX_Wrapper* dxWrapper);
//
//		// Called when a pipeline is active into the pipeline
//		void OnSet(ICmdManager* cmdWrapper);
//
//		// Called when a pipeline is used to gen rays.
//		void OnDispatch(ICmdManager* cmdWrapper);
//
//	protected:
//
//		class Loading {
//			RaytracingPipelineBindings* manager;
//		public:
//			Loading(RaytracingPipelineBindings* manager) :manager(manager) {
//			}
//
//			template<typename L>
//			void Library() {
//				if (!manager->wrapper->loadedLibrary.isNull())
//					throw CA4G::CA4GException("Only one library can be loaded per pipeline.");
//				gObj<L> library = new L();
//				library->OnLoad();
//				manager->loadedLibrary = library;
//			}
//		}* const load;
//
//		class Creating {
//			RaytracingPipelineBindings* manager;
//		public:
//			Creating(RaytracingPipelineBindings* manager) :manager(manager) {
//			}
//
//			template<typename P>
//			gObj<P> Program() {
//				if (manager->wrapper->loadedLibrary.isNull())
//					throw CA4G::CA4GException("Load the dependency library first.");
//				gObj<P> program = new P();
//				program->OnLoad(manager->wrapper->loadedLibrary);
//				manager->wrapper->loadedPrograms.add(program);
//				return program;
//			}
//		}* const create;
//
//		virtual void Setup() = 0;
//
//		RaytracingPipelineBindings() : create(new Creating(this))
//		{
//		}
//	};
//
//}
//
//#endif