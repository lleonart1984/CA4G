#ifndef DXR_SUPPORT_H
#define DXR_SUPPORT_H

#include "ca4g_techniques.h"
#include <wchar.h>

namespace CA4G {

	class ProgramHandle {
		LPCWSTR shaderHandle;
		void* cachedShaderIdentifier;
	protected:
		ProgramHandle(LPCWSTR handle) :shaderHandle(handle) {}
	public:
		ProgramHandle() :shaderHandle(nullptr) {}
		ProgramHandle(const ProgramHandle& other) {
			this->shaderHandle = other.shaderHandle;
		}
		inline bool IsNull() { return shaderHandle == nullptr; }
	};

	class MissHandle : public ProgramHandle {
		MissHandle(LPCWSTR shaderHandle) : ProgramHandle(shaderHandle) { }
	public:
		MissHandle() : ProgramHandle() {}
		MissHandle(const MissHandle& other) : ProgramHandle(other) { }
	};

	class RayGenerationHandle : public ProgramHandle {
		RayGenerationHandle(LPCWSTR shaderHandle) : ProgramHandle(shaderHandle) {}
	public:
		RayGenerationHandle() : ProgramHandle() { }
		RayGenerationHandle(const RayGenerationHandle& other) : ProgramHandle(other) { }
	};

	class AnyHitHandle : public ProgramHandle {
		AnyHitHandle(LPCWSTR shaderHandle) : ProgramHandle(shaderHandle) {}
	public:
		AnyHitHandle() : ProgramHandle() { }
		AnyHitHandle(const AnyHitHandle& other) : ProgramHandle(other) { }
	};

	class ClosestHitHandle : public ProgramHandle {
		ClosestHitHandle(LPCWSTR shaderHandle) : ProgramHandle(shaderHandle) {}
	public:
		ClosestHitHandle() : ProgramHandle() { }
		ClosestHitHandle(const ClosestHitHandle& other) : ProgramHandle(other) { }
	};

	class IntersectionHandle : public ProgramHandle {
		template<typename C> friend class DXIL_Library;
		IntersectionHandle(LPCWSTR shaderHandle) : ProgramHandle(shaderHandle) {}
	public:
		IntersectionHandle() : ProgramHandle() { }
		IntersectionHandle(const IntersectionHandle& other) : ProgramHandle(other) { }
	};

	class HitGroupHandle : public ProgramHandle {
		template<typename C> friend class RTProgram;
		static LPCWSTR CreateAutogeneratedName() {
			static int ID = 0;

			wchar_t* label = new wchar_t[100];
			label[0] = 0;
			wcscat_s(label, 100, TEXT("HITGROUP"));
			wsprintf(&label[8], L"%d",
				ID);
			ID++;

			return label;
		}

		gObj<AnyHitHandle> anyHit;
		gObj<ClosestHitHandle> closestHit;
		gObj<IntersectionHandle> intersection;

		HitGroupHandle(gObj<ClosestHitHandle> closestHit, gObj<AnyHitHandle> anyHit, gObj<IntersectionHandle> intersection)
			: ProgramHandle(CreateAutogeneratedName()), anyHit(anyHit), closestHit(closestHit), intersection(intersection) {}
	public:
		HitGroupHandle() :ProgramHandle() {}
		HitGroupHandle(const HitGroupHandle& other) :ProgramHandle(other) {
			this->anyHit = other.anyHit;
			this->closestHit = other.closestHit;
			this->intersection = other.intersection;
		}
	};

	/// Represents a base class for all raytracing programs.
	class IRTProgram {
		void* __DXProgramWrapper;

		ICmdManager* __CmdWrapper;

		void OnLoad(void* dxWrapper, ICmdManager* cmdWrapper);

	public:
		virtual ~IRTProgram() {}
	};

	class ILibrary {
		void* __DXLibraryWrapper;
	};

	// Represents a Library of raytracing shaders
	class Library : ILibrary {
		Library() :
			load(new Loading(this)),
			create(new Creating(this)) {
		}
	protected:
		virtual void OnLoad() = 0;

		class Loading {
			friend Library;
			ILibrary* library;
			Loading(ILibrary* library): library(library){}
		public:
			void Code(D3D12_SHADER_BYTECODE code);
		} * const load;

		class Creating {
			friend Library;
			ILibrary* library;
			Creating(ILibrary* library) :library(library) {}
		public:
			gObj<RayGenerationHandle> RayGenerationShader(LPCWSTR shader);
			gObj<MissHandle> MissShader(LPCWSTR shader);
			gObj<AnyHitHandle> AnyHit(LPCWSTR shader);
			gObj<ClosestHitHandle> ClosestHit(LPCWSTR shader);
			gObj<IntersectionHandle> Intersection(LPCWSTR shader);
			gObj<HitGroupHandle> HitGroup(gObj<ClosestHitHandle> closest, gObj<AnyHitHandle> anyHit, gObj<IntersectionHandle> intersection);
		} * const create;
	public:
		~Library() {
			delete load;
			delete create;
		}
	};

	template<typename L>
	class RTProgram : public IRTProgram {
		// Gets or sets the context where this program is created.
		gObj<L> __Library;
	public:
		inline gObj<L> Library() {
			return __Library;
		}
	};


	class RTScene {
		void* __InternalRTWrapper;
	};
}

#endif